# Java 面向对象

Java 是面向对象的高级编程语言，类和对象是 Java 程序的构成核心

## 对象

对象，从字面意思来看就是我们面对的物象。由此便可以知道，万事万物皆为对象。比如：一台电脑，一辆汽车，一部手机等等都是对象。

面向对象，从字面意思来看就是我们人面对着一个对象。其实就是指我们从这个对象的整体出发去看它，它由哪些部件组成，它可以做到哪些事情。

比如我们想要买一部手机，我们想要内存大一点的，最新款的，CPU 运算快一点的，能实现发短信和打电话功能的手机。那么这部手机是不是对象呢？它不是。当我们买了一部 iPhone 6 后，它满足我们上面的所有信息。于是我们拿在手上的这部 iphone 6 就是我们的对象。于是我们知道，对象一定是一个具体的、确定的物体。

而这部手机它的样式，颜色，大小，产地，编号等等，便是这部手机的“属性”，这部手机可以打电话、发短信，便是它的“行为”。

面向对象的思想，体现的是人所关注对象的信息聚集在了一个具体的物体上。人们就是通过对象的属性和行为来了解对象。

## 类

> 示例文件：[People](./day13/People.java)
> 示例文件：[NewObject](./day13/NewObject.java)

对于一个具体的对象而言，比如一部 iphone 6，世上还有许多跟这部手机有着同样属性或行为的对象，我们为了方便将它们归类起来，提取出他们相同的属性和行为，而我们把归类起来的这个抽象的概念，称之为类。

比如每个人就是一个对象，小张是一个对象，小明是一个对象。而每个人虽然不同，但却有许多相同的属性和行为，于是我们可以把他们抽象出来，变成一个类，比如人类。

类是封装对象的属性和行为的载体，反过来说具有相同属性和行为的一类实体被称为类。

由此可以总结出类的定义：

-   类是相同或相似对象的一种抽象，是对象的一个模板，它描述一类对象的行为和状态。
-   类是具有相同属性和方法（行为）的对象的集合

什么是对象的属性呢？什么又是对象的行为呢？

属性是对象具有的特征。每个对象的每个属性都拥有特定值。我们上面讲过对象是一个具体并且确定的事物，正是对象属性的值来区分不同的对象，比如我们可以通过一个人的外貌特征区分他。

那什么是对象的行为呢?在计算机中我们通过方法去实现对象的行为，而对象的方法便是对象所具有的操作，比如人会走路、会哭泣、会学习等等都是人的行为，也就是人的方法。

类和对象之间有什么关系吗？在上面的讲解中大家应该有些了解了。类就是对象的抽象(或者模板)，对象就是类的具体（或者实例）。比如手机是一个抽象的概念，它代表着类。而一部 iphone 6 便是手机具象化处理的实体，也就是一个对象。

我们以前说过，Java 是面向对象的语言，而他的体现就在于 Java 程序都以类 class 为组织单元。而一个类是对象的抽象，所以类由属性和方法两部分组成。

### 定义

定义一个类，有三个步骤：

1.  定义类名，用于区分不同的类。如下代码中 public class 后面跟的就是类名。class是声明类的关键字，类名后面跟上大括号，大括号里面就是类的一些信息。public为权限修饰符

    ```java
    public class 类名{
    //定义属性部分（成员变量）
    属性1的类型 属性1;
    属性2的类型 属性2;
    ...
    //定义方法部分

    方法1;
    方法2;
    ...
    }
    ```

2.  编写类的属性。对象有什么，需要通过属性来表示。属性的定义是写在类名后面的大括号里，在定义属性时，要明确属性的类型。在一个类当中可以写一个或多个属性。当然也可以不定义属性

3.  编写类的方法。方法也是写在大括号里面。可以定义一个方法或多个方法，当然也可以不定义方法

一个类可以包含以下 **类型变量**:

-   局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁
-   成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问
-   类变量：也叫静态变量，类变量也声明在类中，方法体之外，但必须声明为 static 类型

# Java 对象

> 示例文件：[NewObject](./day13/NewObject.java)

创建对象的语法如下：

```Java
类名 对象名 = new 类名();
```

比如对People这个类，我想实例化LiLei这个人。LiLei 的数据类型便是 People 这个类型。（类可以看成是我们自己定义的数据类型）

```java
People LiLei = new People();
```

创建对象后，我们就要使用对象了，使用对象无非就是对属性和方法进行操作和调用。语法如下:

```java
//引用对象属性
对象名.属性

//引用对象方法
对象名.方法
```

**在使用时注意，成员变量可以被本类的所有方法所使用，同时可以被与本类有关的其他类所使用。而局部变量只能在当前的方法中使用**

在这里我们要讲到一个关于作用域的知识了。作用域可以简单地理解为变量的生存期或者作用范围，也就是变量从定义开始到什么时候消亡:

1.  局部变量的作用域仅限于定义它的方法内。而成员变量的作用域在整个类内部都是可见的
2.  同时在相同的方法中，不能有同名的局部变量；在不同的方法中，可以有同名的局部变量
3.  成员变量和局部变量同名时，局部变量具有更高的优先级

# 类的构造方法

每个类都有构造方法，在创建该类的对象的时候他们将被调用，如果没有定义构造方法，Java 编译器会提供一个默认构造方法。 创建一个对象的时候，至少调用一个构造方法

比如在新建一个对象new Object()，括号中没有任何参数，代表调用一个无参构造方法（默认构造方法就是一个无参构造方法）。构造方法的名称必须与类名相同，一个类可以定义多个构造方法

构造方法具体内容：

1.  构造方法的名称与类名相同，且没有返回值。它的语法格式如下：

    ```Java
    //与类同名，可以指定参数，没有返回值
    public 构造方法名(){
    //初始化代码
    }
    ```

    示例：

    ```java
    public class People{
    //无参构造方法
      public People(){

      }
      //有一个参数的构造方法
      public People(int age){

      }

    }
    ```

    具体构造方法演示：

    ```java
    public class People {
    //属性（成员变量）有什么
        double height;     //身高
        int age;           //年龄
        int sex;       //性别，0为男性，非0为女性

        //构造函数，初始化了所有属性
        public People(double h, int a, int s){
            height = h;
            age = a;
            sex = s;
        }
    }
    ```

    ```java
    //创建对象，调用我们自己定义的有参构造方法
    People XiaoMing = new People(168, 21, 1);
    ```

    上面的例子中通过 **new** 关键字将类实例化成对象，而 **new** 后面跟的就是构造方法。于是可以知道 **new + 构造方法** 可以创建一个新的对象。

2.  如果在定义类的时候没有写构造方法，系统会默认生成一个无参构造方法，这个构造方法什么也不会做

3.  当有指定的构造方法时，系统都不会再添加无参构造方法了

4.  构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应的方法

# static

**静态成员：**

Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问

```java
public class StaticTest{
    public static String string="shiyanlou";
    public static void main(String[] args){
        //静态成员不需要实例化 直接就可以访问
        System.out.println(StaticTest.string);
        //如果不加static关键字 需要这样访问
        StaticTest staticTest=new StaticTest();
        System.out.println(staticTest.string);
        //如果加上static关键字，上面的两种方法都可以使用
    }
}
```

**静态方法：**

被 static 修饰的方法是静态方法，静态方法不依赖于对象，不需要将类实例化便可以调用，由于不实例化也可以调用，所以不能有 this，也不能访问非静态成员变量和非静态方法。但是非静态成员变量和非静态方法可以访问静态方法

# final

**final** 关键字可以修饰类、方法、属性和变量：

1.  final 修饰类，则该类不允许被继承，为最终类
2.  final 修饰方法，则该方法不允许被覆盖（重写）
3.  final 修饰属性：则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在构造方法中赋值（但只能选其一）
4.  final 修饰变量，则该变量的值只能赋一次值，即常量

# 权限修饰符

|   访问修饰符   |  本类 |  同包 |  子类 |  其他 |
| :-------: | :-: | :-: | :-: | :-: |
|  private  |  ✔︎ |     |     |     |
|     默认    |  ✔︎ |  ✔︎ |     |     |
| protected |  ✔︎ |  ✔︎ |  ✔︎ |     |
|   public  |  ✔︎ |  ✔︎ |  ✔︎ |  ✔︎ |

如图所示，代表了不同的访问修饰符的访问范围，比如private修饰的属性或者方法，只能在当前类中访问或者使用。默认是什么修饰符都不加，默认在当前类中和同一包下都可以访问和使用。protected修饰的属性或者方法，对同一包内的类和所有子类可见。public修饰的属性或者方法，对所有类可见。

我们可以举一个例子，比如 money，如果我们用private修饰代表着这是私有的，只能我自己可以使用。如果是protected代表着我可以使用，和我有关系的人，比如儿子也可以用。如果是public就代表了所有人都可以使用

# 封装

> 示例文件：[People](./day14/People.java)
> 示例文件：[NewObject](./day14/NewObject.java)

**封装，即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别**

这样做有什么好处？

1.  只能通过规定的方法访问数据
2.  隐藏类的实例细节，方便修改和实现

我们在开汽车的时候，只用去关注如何开车，我们并不在意车子是如何实现的，这就是封装
